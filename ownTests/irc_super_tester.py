#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Ultra‑Comprehensive IRC Server Tester (RFC 1459-ish)

• Async, multi-client, multi-channel scenario tests
• Focuses on 42 ft_irc common requirements + robust edge cases
• Lax matching with numerics/keywords to accommodate server variations

USAGE
-----
python3 irc_super_tester.py --host 127.0.0.1 --port 6667 --password pass \
    --verbose

Exit code is non-zero if any test fails.

AUTHOR
------
Generated by ChatGPT for Ahmet (ft_irc project).
"""
from __future__ import annotations
import asyncio
import argparse
import re
import sys
from dataclasses import dataclass, field
from typing import Callable, Awaitable, List, Optional, Tuple, Dict, Any

# ----------------------------- Utility -------------------------------------
ANSI = {
    "RESET": "\033[0m",
    "GREEN": "\033[32m",
    "RED": "\033[31m",
    "YELLOW": "\033[33m",
    "CYAN": "\033[36m",
    "BOLD": "\033[1m",
}

def c(s, color):
    return f"{ANSI[color]}{s}{ANSI['RESET']}"

# --------------------------- IRC Client ------------------------------------
class IRCClient:
    def __init__(self, name: str, host: str, port: int, password: Optional[str],
                 verbose: bool = False):
        self.name = name
        self.host = host
        self.port = port
        self.password = password
        self.verbose = verbose
        self.reader: asyncio.StreamReader
        self.writer: asyncio.StreamWriter
        self.recv_log: List[str] = []
        self.connected = False

    async def connect(self):
        self.reader, self.writer = await asyncio.open_connection(self.host, self.port)
        self.connected = True
        if self.verbose:
            print(c(f"[{self.name}] CONNECTED {self.host}:{self.port}", "CYAN"))

    async def close(self):
        if self.connected:
            try:
                self.writer.close()
                await self.writer.wait_closed()
            except Exception:
                pass
            self.connected = False
            if self.verbose:
                print(c(f"[{self.name}] CLOSED", "CYAN"))

    def _send_raw(self, line: str):
        if not line.endswith("\r\n"):
            line += "\r\n"
        if self.verbose:
            print(c(f"[{self.name}] >>> {line.rstrip()}", "YELLOW"))
        self.writer.write(line.encode("utf-8", errors="ignore"))

    async def drain(self):
        await self.writer.drain()

    def send(self, cmd: str, *params: str, trailing: Optional[str] = None):
        parts = [cmd]
        for p in params:
            if ' ' in p or p == '' or p.startswith(':'):
                # put in trailing if needed
                if trailing is None:
                    trailing = p
                else:
                    trailing += f" {p}"
            else:
                parts.append(p)
        if trailing is not None:
            parts.append(':' + trailing)
        self._send_raw(' '.join(parts))

    def send_raw(self, raw: str):
        self._send_raw(raw)

    async def recv_line(self, timeout: float = 2.0) -> Optional[str]:
        try:
            line = await asyncio.wait_for(self.reader.readline(), timeout=timeout)
        except asyncio.TimeoutError:
            return None
        if not line:
            return None
        s = line.decode("utf-8", errors="ignore").rstrip("\r\n")
        self.recv_log.append(s)
        if self.verbose:
            print(c(f"[{self.name}] <<< {s}", "GREEN"))
        return s

    async def expect_regex(self, pattern: str, timeout: float = 2.0) -> bool:
        """Read lines until regex matches (within timeout window)."""
        deadline = asyncio.get_event_loop().time() + timeout
        regex = re.compile(pattern)
        while asyncio.get_event_loop().time() < deadline:
            line = await self.recv_line(timeout=max(0.05, deadline - asyncio.get_event_loop().time()))
            if line is None:
                await asyncio.sleep(0.01)
                continue
            if regex.search(line):
                return True
        return False

    async def expect_numeric(self, code: str, contains: Optional[str] = None, timeout: float = 2.0) -> bool:
        pat = fr"\s{re.escape(code)}\s"
        if contains:
            pat = fr"{pat}.*{re.escape(contains)}"
        return await self.expect_regex(pat, timeout=timeout)

    async def expect_command(self, cmd: str, timeout: float = 2.0) -> bool:
        pat = fr"\s{re.escape(cmd)}\b"
        return await self.expect_regex(pat, timeout=timeout)

# --------------------------- Test Framework --------------------------------
@dataclass
class TestResult:
    name: str
    ok: bool
    details: str = ""

@dataclass
class TestCase:
    name: str
    func: Callable[["TestContext"], Awaitable[None]]

@dataclass
class TestContext:
    host: str
    port: int
    password: Optional[str]
    verbose: bool
    clients: Dict[str, IRCClient] = field(default_factory=dict)

    async def new_client(self, name: str) -> IRCClient:
        c = IRCClient(name, self.host, self.port, self.password, self.verbose)
        await c.connect()
        self.clients[name] = c
        return c

    async def close_all(self):
        for c in list(self.clients.values()):
            await c.close()
        self.clients.clear()

# --------------------------- Helpers ---------------------------------------
async def register_minimal(c: IRCClient, nick: str, user: Optional[str] = None, real: str = "Real"):
    if c.password is not None:
        c.send("PASS", c.password)
        await c.drain()
    c.send("NICK", nick)
    await c.drain()
    c.send("USER", user or (nick + "u"), "host", "server", trailing=real)
    await c.drain()
    # Expect welcome (001) eventually
    await c.expect_numeric("001", timeout=2.0)

async def drain_until_silent(client: IRCClient, quiet_ms: int = 150):
    """Read until no data arrives for quiet_ms."""
    deadline = asyncio.get_event_loop().time() + (quiet_ms / 1000.0)
    while True:
        rem = deadline - asyncio.get_event_loop().time()
        if rem <= 0:
            break
        line = await client.recv_line(timeout=rem)
        if line is None:
            break
        deadline = asyncio.get_event_loop().time() + (quiet_ms / 1000.0)

# --------------------------- Individual Tests ------------------------------
async def test_greeting_and_errors(ctx: TestContext):
    a = await ctx.new_client("A")
    # Server banner/hello (optional). Then try PASS without param => 461
    a.send("PASS")
    await a.drain()
    assert await a.expect_numeric("461", contains="PASS", timeout=1.0), "Expected ERR_NEEDMOREPARAMS 461 for PASS"

    # Wrong PASS => 464 (if password configured)
    if ctx.password:
        a.send("PASS", "wrongpass")
        await a.drain()
        assert await a.expect_numeric("464", timeout=1.0), "Expected 464 Password incorrect"

    # USER without PASS (when password set) should yield 464 or 451 depending on server policy
    a.send("USER", "onlyoneparam")
    await a.drain()
    assert await a.expect_regex(r"\s(461|451|464)\s.*USER", timeout=1.0), "Expected error for USER missing params or not registered"
    await a.close()

async def test_successful_registration(ctx: TestContext):
    a = await ctx.new_client("Reg")
    await register_minimal(a, "alice")
    # NICK already set change to same nick => either silent or RPL_YOURHOST/002 etc; ensure still alive
    a.send("NICK", "alice")
    await a.drain()
    await drain_until_silent(a)
    await a.close()

async def test_double_nick_collision(ctx: TestContext):
    a = await ctx.new_client("N1")
    b = await ctx.new_client("N2")
    await register_minimal(a, "bob")
    await register_minimal(b, "charlie")
    # Try to steal bob
    b.send("NICK", "bob")
    await b.drain()
    assert await b.expect_numeric("433", timeout=1.0), "Expected 433 ERR_NICKNAMEINUSE"
    await a.close(); await b.close()

async def test_join_and_names(ctx: TestContext):
    a = await ctx.new_client("C1")
    await register_minimal(a, "dana")
    a.send("JOIN", "#room1")
    await a.drain()
    # Expect RPL_NAMREPLY (353) and RPL_ENDOFNAMES (366)
    assert await a.expect_numeric("353", timeout=1.0), "Expected 353 RPL_NAMREPLY"
    assert await a.expect_numeric("366", timeout=1.0), "Expected 366 RPL_ENDOFNAMES"
    await a.close()

async def test_privmsg_channel_and_user(ctx: TestContext):
    a = await ctx.new_client("P1")
    b = await ctx.new_client("P2")
    await register_minimal(a, "erin")
    await register_minimal(b, "frank")

    # Errors: missing recipient 411 and missing text 412
    a.send("PRIVMSG")
    await a.drain()
    assert await a.expect_numeric("411", timeout=1.0), "Expected 411 ERR_NORECIPIENT"
    a.send("PRIVMSG", "frank")
    await a.drain()
    assert await a.expect_numeric("412", timeout=1.0), "Expected 412 ERR_NOTEXTTOSEND"

    # Direct user message
    a.send("PRIVMSG", "frank", trailing="hello user")
    await a.drain()
    assert await b.expect_command("PRIVMSG", timeout=1.0), "frank should receive PRIVMSG"

    # Channel message (must join both)
    a.send("JOIN", "#c1")
    b.send("JOIN", "#c1")
    await a.drain(); await b.drain()
    await a.expect_numeric("353", timeout=1.0)
    await b.expect_numeric("353", timeout=1.0)

    a.send("PRIVMSG", "#c1", trailing="hello channel")
    await a.drain()
    assert await b.expect_command("PRIVMSG", timeout=1.0), "channel msg should reach other member"
    await a.close(); await b.close()

async def test_topic_and_modes(ctx: TestContext):
    a = await ctx.new_client("M1")
    b = await ctx.new_client("M2")
    await register_minimal(a, "ops")
    await register_minimal(b, "user")

    a.send("JOIN", "#m")
    await a.drain(); await a.expect_numeric("353", timeout=1.0)

    # Make a op scenario: many ft_irc implementations give creator +o automatically
    # Protect topic (+t) and set a topic
    a.send("MODE", "#m", "+t")
    await a.drain(); await drain_until_silent(a)

    a.send("TOPIC", "#m", trailing="welcome")
    await a.drain()
    assert await a.expect_command("TOPIC", timeout=1.0) or await a.expect_numeric("332", timeout=1.0), "Topic should be set/echoed"

    # Join as normal user and try to set topic (should get 482 or 482-like)
    b.send("JOIN", "#m")
    await b.drain(); await b.expect_numeric("353", timeout=1.0)

    b.send("TOPIC", "#m", trailing="hack")
    await b.drain()
    assert await b.expect_numeric("482", timeout=1.0), "Expected 482 ERR_CHANOPRIVSNEEDED for +t"

    await a.close(); await b.close()

async def test_kick_and_invite_only(ctx: TestContext):
    a = await ctx.new_client("K1")
    b = await ctx.new_client("K2")
    c = await ctx.new_client("K3")
    await register_minimal(a, "op")
    await register_minimal(b, "guest1")
    await register_minimal(c, "guest2")

    # Create channel and make it invite-only +i
    a.send("JOIN", "#vip")
    await a.drain(); await a.expect_numeric("353", timeout=1.0)
    a.send("MODE", "#vip", "+i")
    await a.drain(); await drain_until_silent(a)

    # Non-invited user cannot join => 473
    b.send("JOIN", "#vip")
    await b.drain()
    assert await b.expect_numeric("473", timeout=1.0), "Expected 473 ERR_INVITEONLYCHAN"

    # Invite then JOIN works
    a.send("INVITE", "guest1", "#vip")
    await a.drain(); await drain_until_silent(a)
    b.send("JOIN", "#vip")
    await b.drain(); assert await b.expect_numeric("353", timeout=1.0)

    # KICK by op
    a.send("KICK", "#vip", "guest1", trailing="bye")
    await a.drain()
    assert await b.expect_command("KICK", timeout=1.0) or await b.expect_regex(r"\sKICK\s#vip\sguest1"), "Kicked user should see KICK"

    # Kicked user cannot send to channel => 404 (cannot send to channel)
    b.send("PRIVMSG", "#vip", trailing="still here?")
    await b.drain()
    assert await b.expect_numeric("404", timeout=1.0), "Expected 404 Cannot send to channel"

    await a.close(); await b.close(); await c.close()

async def test_keyed_channel_and_limits(ctx: TestContext):
    a = await ctx.new_client("L1")
    b = await ctx.new_client("L2")
    c = await ctx.new_client("L3")
    await register_minimal(a, "keeper")
    await register_minimal(b, "u1")
    await register_minimal(c, "u2")

    # Create +k key and +l limit 2
    a.send("JOIN", "#key")
    await a.drain(); await a.expect_numeric("353", timeout=1.0)
    a.send("MODE", "#key", "+k", "sekret")
    a.send("MODE", "#key", "+l", "2")
    await a.drain(); await drain_until_silent(a)

    # Wrong key => 475
    b.send("JOIN", "#key", "wrong")
    await b.drain(); assert await b.expect_numeric("475", timeout=1.0), "Expected 475 bad key"
    # Right key join
    b.send("JOIN", "#key", "sekret")
    await b.drain(); await b.expect_numeric("353", timeout=1.0)

    # Channel is full now (limit=2)
    c.send("JOIN", "#key", "sekret")
    await c.drain(); assert await c.expect_numeric("471", timeout=1.0), "Expected 471 channel is full"

    await a.close(); await b.close(); await c.close()

async def test_whois_ping_quit(ctx: TestContext):
    a = await ctx.new_client("W1")
    await register_minimal(a, "zara")
    # WHOIS self
    a.send("WHOIS", "zara")
    await a.drain()
    # Expect at least 311 (RPL_WHOISUSER) and 318 (RPL_ENDOFWHOIS) or server variants
    assert await a.expect_regex(r"\s(311|318)\s|RPL_WHOIS", timeout=1.5), "Expected WHOIS reply"

    # PING/PONG
    a.send("PING", "server")
    await a.drain()
    assert await a.expect_command("PONG", timeout=1.0), "Expected PONG"

    # QUIT with message
    a.send("QUIT", trailing="bye")
    await a.drain()
    # Connection should close afterwards
    await asyncio.sleep(0.2)
    await a.close()

# --------------------------- Test Suite ------------------------------------
ALL_TESTS: List[TestCase] = [
    TestCase("Greeting & basic error numerics", test_greeting_and_errors),
    TestCase("Successful registration", test_successful_registration),
    TestCase("Nick collision (433)", test_double_nick_collision),
    TestCase("JOIN + NAMES (353/366)", test_join_and_names),
    TestCase("PRIVMSG to user & channel + errors", test_privmsg_channel_and_user),
    TestCase("TOPIC + modes (+t / 482)", test_topic_and_modes),
    TestCase("KICK + invite-only (+i/473/404)", test_kick_and_invite_only),
    TestCase("Keyed channel + limit (+k/+l/475/471)", test_keyed_channel_and_limits),
    TestCase("WHOIS, PING/PONG, QUIT", test_whois_ping_quit),
]

# --------------------------- Runner ----------------------------------------
async def run_tests(ctx: TestContext, selected: Optional[List[str]] = None) -> Tuple[int, List[TestResult]]:
    results: List[TestResult] = []
    failed = 0
    tests = [t for t in ALL_TESTS if (not selected or t.name in selected)]
    for t in tests:
        if ctx.verbose:
            print(c(f"\n=== RUN: {t.name} ===", "BOLD"))
        try:
            # fresh context each test to avoid state bleed
            await t.func(ctx)
            await ctx.close_all()
            results.append(TestResult(t.name, True))
            if ctx.verbose:
                print(c(f"=== OK: {t.name} ===", "GREEN"))
        except AssertionError as e:
            failed += 1
            results.append(TestResult(t.name, False, str(e)))
            print(c(f"=== FAIL: {t.name}: {e} ===", "RED"))
            await ctx.close_all()
        except Exception as e:
            failed += 1
            results.append(TestResult(t.name, False, f"Unhandled: {e}"))
            print(c(f"=== ERROR: {t.name}: {e} ===", "RED"))
            await ctx.close_all()
    return failed, results

# --------------------------- Main ------------------------------------------
def parse_args():
    p = argparse.ArgumentParser(description="Ultra IRC tester")
    p.add_argument("--host", default="127.0.0.1")
    p.add_argument("--port", type=int, default=6667)
    p.add_argument("--password", default=None, help="PASS password if required")
    p.add_argument("--verbose", action="store_true")
    p.add_argument("--only", nargs="*", help="Run only the tests with exact names")
    return p.parse_args()

async def amain():
    args = parse_args()
    ctx = TestContext(host=args.host, port=args.port, password=args.password, verbose=args.verbose)
    failed, results = await run_tests(ctx, selected=args.only)

    # Summary
    total = len(results)
    ok = sum(1 for r in results if r.ok)
    print()
    if failed == 0:
        print(c(f"ALL TESTS PASSED ({ok}/{total})", "GREEN"))
    else:
        print(c(f"{failed} TEST(S) FAILED ({ok}/{total})", "RED"))
        for r in results:
            if not r.ok:
                print(c(f" - {r.name}: {r.details}", "RED"))
    sys.exit(1 if failed else 0)

if __name__ == "__main__":
    try:
        asyncio.run(amain())
    except KeyboardInterrupt:
        print("Interrupted.")
